# Описание Json-файла конфигурации управления памятью A1 v4

A1 Memory Management v4 разработан с использованием фреймворка HAMv2, поэтому параметры управления памятью можно настраивать через конфигурационные файлы без изменения исходного кода. В этом документе подробно рассказывается, как настроить файлы конфигурации Json.

## Параметр пользовательских модулей

```json
"config": {
    "path": "/sdcard/Android/HChai/HC_memory",
    "modulePath": "/data/adb/modules/Hc_memory",
    "list": {
        "name": "名单列表.conf",
        "whiteList": {
            "optional": true,
            "smart": true,
            "system": false
        }
    }
}
```

| имя поля   | тип    | описание                                                                                                                  |
| ---------- | ------ | ------------------------------------------------------------------------------------------------------------------------- |
| path       | string | путь к файлу конфигурации                                                                                                 |
| modulePath | string | имя модуля путь                                                                                                           |
| name       | string | Имя файла конфигурационного списка, в котором хранятся белый список и смарт-список                                        |
| optional   | bool   | Включить ли белый список, после включения процессы в белом списке не будут убиты                                          |
| smart      | bool   | Включить ли смарт-белый список, после его включения процесс будет автоматически идентифицирован и добавлен в белый список |
| system     | bool   | Включить ли системный белый список, все системное ПО будет добавлено в белый список после включения                       |

Следует отметить, что добавление белого списка должно быть добавлено в следующем формате:

```
WHITE Имена пакетов
```

## Путь/уровень журнала

Записывайте журналы, когда запущено управление памятью A1 v4, и вы можете настроить вывод журнала, изменив путь журнала и уровень журнала.

```json
"log": {
    "path": "/sdcard/Android/HChai/HC_memory/Run.log",
    "level": "info"
}
```

|имя поля |тип |описание |
| ------ | ------ | ---------------------------------------------------- |
|path |string |путь журнала |
|level |string |уровень лога, варианты: отладка, информация, предупреждение, ошибка, критично |

Если вы хотите отключить журнал, вы можете установить критический уровень журнала или, если вы хотите видеть только журнал текущих ошибок, вы можете настроить его на предупреждение.

## Основные рабочие параметры функции

Функция этого параметра заключается в том, что после изменения приложения переднего плана переключение процесса переднего плана в течение определенного периода времени не приведет к запуску основной функции.

```json
"initProcess": {
    "afterTopChange": {
        "sleep": 1
    }
}
```

|имя поля |тип |описание |
| ------ | ---- | ------------------ |
|sleep |int |время ожидания в секундах |

"sleep" указывает время ожидания после изменения приоритетного приложения в секундах. Установка его на 1 секунду означает, что после изменения приложения переднего плана подождите 1 секунду, прежде чем переключиться на передний план, прежде чем снова выполнять основную функцию. Другими словами, основная функция не будет выполнена, если передний план переключится в течение 1 секунды. Этот параметр можно использовать для управления повторным выполнением основной функции в течение периода времени после изменения приложения переднего плана, чтобы предотвратить ненужные операции или трату ресурсов.

## Управление памятью A1 завершает ненужные процессы

Управление памятью A1 v4 может завершать ненужные процессы для освобождения памяти. Ниже приведены примеры параметров, используемых для управления этим поведением:

```json
"a1Memory": {
    "enable": true,
    "oomAdj": 905
}
```

|имя поля |тип |описание |
| ------ | ---- | ---------------------------------- |
|enable |bool |Включить ли управление памятью A1 для завершения ненужных процессов |
| oomAdj | int | Значение больше oomAdj будет прекращено |

- `enable` указывает, следует ли включить управление памятью A1 для завершения ненужных процессов. Если установлено значение true, управление памятью A1 выполнит операцию завершения процесса; если установлено значение false, управление памятью A1 не завершит ни один процесс.
- `oomAdj` указывает значение настройки, используемое для определения того, завершен ли процесс. Только когда значение oomAdj процесса больше установленного значения "oomAdj", они будут завершены управлением памятью A1. Это значение находится в диапазоне от 0 до 1000. Чем больше значение, тем меньше процессов завершается, и наоборот, чем меньше значение, тем больше процессов завершается. Следует отметить, что не все процессы будут идентифицированы и остановлены, будут прекращены только те процессы, которые алгоритм оценивает как ненужные и у которых значение oomAdj больше заданного значения.

## Разрешить приложению автоматически освобождать память

Управление памятью A1 v4 позволяет приложениям автоматически освобождать память. Ниже приведены примеры параметров, используемых для управления этим поведением:

```json
"initCutMemory": {
    "freed": {
        "enable": true,
        "level": "80",
        "regex": "( CAC|SVC|CEM).*",
        "change": 20
    }
}
```

|имя поля |тип |описание |
| ------ | ------ | -------------------------------------- |
|enable |bool |Разрешить ли приложению автоматически освобождать память |
|level |string |0-100, чем выше значение, тем больше памяти будет освобождено |
|regex |string |Регулярное выражение, соответствующее состоянию приложения, которому необходимо освободить память |
|change |int |сколько раз передний план переключается для выполнения операции автоотпуска |

- `enable` указывает, разрешить ли приложению автоматически освобождать память. Если установлено значение true, управление памятью A1 реализует приложение для автоматического освобождения операции с памятью; если установлено значение false, управление памятью A1 не будет выполнять приложение для автоматического освобождения операции с памятью.
- `level` указывает степень освобождения памяти. Это значение находится в диапазоне от 0 до 100. Чем выше значение, тем больше памяти будет освобождено, и наоборот, чем меньше значение, тем меньше памяти будет освобождено.
- `regex` представляет собой регулярное выражение, используемое для сопоставления состояния приложения, которому необходимо освободить память. Память будет освобождена только для соответствующего состояния приложения. Правила сопоставления регулярных выражений такие же, как и в языке JS, вы можете обратиться к [здесь](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions).
- `change` указывает, сколько раз приложение переднего плана переключается для выполнения операции автоматического выпуска. Я рекомендую это значение между 10-30.

Как узнать, память каких приложений нужно освободить? Получить статус можно командой:
```shell
Заказ: dumpsys activity lru
выход: ACTIVITY MANAGER LRU PROCESSES (dumpsys activity lru)
  Activities:
  #67: fg     TOP  LCMN 6918:bin.mt.plus/u0a226 act:activities|recents
  #66: vis    BFGS ---N 3152:com.miui.home/u0a80 act:activities
  #65: prev   LAST ---- 25424:com.omarea.vtools/u0a672 act:activities|recents
  #64: cch    CAC  ---- 5586:com.kiwibrowser.browser/u0a91 act:activities|recents
  #63: cch    CACC ---- 5961:com.kiwibrowser.browser:kiwi_sandboxed_process0:org.chromium.content.app.KiwiSandboxedProcessService0:4/u0a91i-8996 act:client
  #62: cch+10 CAC  ---- 22204:com.tencent.mobileqq/u0a481 act:activities|recents
  #61: cch+10 CACC ---- 22308:com.tencent.mobileqq:MSF/u0a481 act:client
  #60: cch+20 CACC ---- 5715:com.kiwibrowser.browser:kiwi_privileged_process0/u0a91 act:client
  #59: cch+20 CACC ---- 5748:com.kiwibrowser.browser:kiwi_sandboxed_process0:org.chromium.content.app.KiwiSandboxedProcessService0:1/u0a91i-8999 act:client
  #58: hvy    CAC  ---- 31098:com.coolapk.market/u0a677 act:activities|recents
  #57: hvy    SVC  ---- 9696:com.tencent.mm/u0a201 act:activities|recents
  #56: vis    SVC  ---- 4370:com.google.android.gms/u0a159 act:client
  #55: vis    BFGS ---N 4265:com.google.android.gms.persistent/u0a159 act:client
  #54: hvy    SVC  ---- 9290:com.tencent.mm:push/u0a201 act:client
  #53: cch+30 CACC ---- 6104:com.kiwibrowser.browser:kiwi_sandboxed_process0:org.chromium.content.app.KiwiSandboxedProcessService0:5/u0a91i-8995 act:client
  #52: hvy    CAC  ---- 22734:org.telegram.plus/u0a386 act:activities|recents
  #51: hvy    CAC  ---- 24029:mark.via/u0a222 act:activities|recents
  #50: cch+30 CACC ---- 24074:com.google.android.webview:sandboxed_process0:org.chromium.content.app.SandboxedProcessService0:0/u0a222i1 act:client
  #49: cch+40 CAC  ---- 25274:com.google.android.apps.translate/u0a548 act:activities|recents
  #48: hvy    CAC  ---- 21987:com.github.kr328.clash/u0a329 act:activities|recents
  Other:
  #47: fg     BTOP ---N 4315:com.miui.securitycenter.remote/1000
  #46: vis    BFGS ---N 4948:com.miui.powerkeeper/1000
  #45: cch+ 5 CEM  ---- 4209:com.miui.weather2/u0a203
  #44: vis    BTOP ---N 4853:com.miui.securitycenter.bootaware/1000
  #43: cch+15 CEM  ---- 11717:com.android.mms/u0a66
  #42: cch+25 CEM  ---- 7159:egrn.pucm.pgo/u0a764
  #41: psvc   PER  LCMN 4197:com.android.providers.media.module/u0a197
  #40: prcp   FGS  ---N 5977:com.miui.gallery/u0a68
  #39: vis    FGS  ---N 22036:com.github.kr328.clash:background/u0a329 act:client
  #38: cch+35 SVC  ---- 31061:com.android.settings:remote/1000
  #37: svcb   SVC  ---- 4569:com.xiaomi.xmsf/u0a141
  #36: cch+45 CEM  ---- 5950:com.xiaomi.aiasst.service/1000
  #35: prcp   FGS  ---N 20376:com.miui.misound/u0a126
  #34: fg     BFGS ---N 5543:com.xiaomi.misettings:remote/1000
  #33: fg     FGS  ---N 5665:com.miui.notification:remote/1000
  #32: cch+55 CEM  ---- 4396:com.android.providers.calendar/u0a50
  #31: cch+65 CEM  ---- 9210:com.xiaomi.market:guard/u0a117
  #30: hvy    CEM  ---- 9075:com.xiaomi.joyose/1000
  #29: cch+75 CEM  ---- 8819:com.miui.core/u0a145
  #28: cch+85 CEM  ---- 8352:com.android.shell/2000
  #27: prcp   TRNB ---- 4793:com.lbe.security.miui/u0a52
  #26: vis    BFGS LCMN 5035:com.sohu.inputmethod.sogou.xiaomi/u0a134 act:treated
  #25: pers   PER  LCMN 4180:com.miui.face/1000
  #24: pers   PER  LCMN 4171:com.qualcomm.location/u0a182
  #23: pers   PER  LCMN 4149:org.mipay.android.manager/u0a150
  #22: pers   PER  LCMN 4130:com.tencent.soter.soterserver/u0a151 act:client
  #21: pers   PER  LCMN 4126:com.qualcomm.qti.workloadclassifier/u0a191
  #20: pers   PER  LCMN 4073:com.xiaomi.mircs/u0a76
  #19: pers   PER  LCMN 4081:com.xiaomi.xmsfkeeper/u0a140
  #18: pers   PER  LCMN 4061:com.miui.voicetrigger/u0a102
  #17: pers   PER  LCMN 4038:.slas/1000
  #16: pers   PER  LCMN 4001:system/u0a46
  #15: pers   PER  LCMN 4003:org.ifaa.aidl.manager/u0a149
  #14: pers   PER  LCMN 3996:com.android.nfc/1027
  #13: pers   PER  LCMN 3967:com.miui.contentcatcher/1000
  #12: vis    BFGS LCMN 2913:com.miui.miwallpaper/u0a119
  #11: vis    IMPF ---- 3432:com.android.smspush/u0a187
  #10: pers   PER  LCMN 3135:com.android.systemui/1000
  # 9: pers   PER  LCMN 3119:com.android.phone/1001
  # 8: pers   PER  LCMN 3104:com.xiaomi.finddevice/6110
  # 7: pers   PER  LCMN 3103:com.android.se/1068
  # 6: pers   PER  LCMN 3137:.dataservices/1001
  # 5: pers   PER  LCMN 3106:com.qualcomm.qti.devicestatisticsservice/u0a161
  # 4: pers   PER  LCMN 3094:org.codeaurora.ims/u0a184
  # 3: pers   PER  LCMN 3098:com.qti.qualcomm.mstatssystemservice/u0a186
  # 2: pers   PER  LCMN 3072:com.qti.phone/u0a175
  # 1: pers   PER  LCMN 3051:.qtidataservices/u0a148
  # 0: sys    PER  LCMN 1824:system/1000
```
Велика вероятность, что вы не знаете, что означает статус процесса, поясню вкратце:
- PER (Persistent): это постоянное состояние, означающее, что процесс не будет уничтожен системой. Обычно это относится к критически важным системным процессам, таким как системные службы.
- PERU (Persistent and Upward): это также постоянное состояние, но оно позволяет системе завершить процесс, если ему не хватает памяти. Это означает, что в некоторых случаях процесс может быть остановлен, но в большинстве случаев он будет продолжать работать.
- TOP (Вверху): Это указывает на то, что процесс является видимым в данный момент приложением переднего плана, т. е. приложением, с которым взаимодействует пользователь.
- BTOP (Bound Top): это состояние похоже на TOP, но система может остановить процесс из-за нехватки памяти. Обычно это происходит, когда на устройстве запущено много приложений, а памяти мало.
- FGS (служба переднего плана): указывает, что процесс предоставляет службы переднего плана. Служба переднего плана — это служба, которая взаимодействует с пользователем, отображая уведомления или другой пользовательский интерфейс.
- BFGS (привязанная служба переднего плана): аналогична FGS, но система может завершить процесс из-за нехватки памяти.
- IMPF (важный фон): указывает, что процесс является важным фоновым процессом, который выполняет некоторые важные задачи, но не должен отображаться для пользователя на переднем плане.
- IMPB (важный фон и вверх): это состояние похоже на IMPF, но система может остановить процесс из-за нехватки памяти.
- TRNB (Trusted Background): указывает, что процесс является доверенным фоновым процессом и выполняет некоторые доверенные задачи.
- BKUP (Резервное копирование): Указывает, что процесс выполняет операции резервного копирования приложений, такие как резервное копирование данных в облако или другие устройства хранения.
- SVC (служба): указывает, что процесс является фоновой службой, выполняющей определенные функции, и ее не нужно отображать для пользователя на переднем плане.
- RCVR (получатель): указывает, что процесс является широковещательным приемником для приема и обработки широковещательных сообщений, отправленных системой или приложениями.
- TPSL (Top Sleeping): указывает, что процесс находится в состоянии ожидания верхнего уровня, то есть приложение находится в состоянии ожидания, но остается на переднем плане.
- HVY (Heavy Weight): Указывает, что процесс является тяжеловесным, обычно потому, что он использует много системных ресурсов, таких как память или ЦП.
- HOME: указывает, что процесс является приложением домашнего экрана устройства, рабочим столом, который видит пользователь.
- ПОСЛЕДНИЙ: Указывает, что процесс является последним завершенным процессом приложения.
- CAC (кэшированный клиент активности): указывает, что процесс является активным клиентом кэша, обычно это приложение, работающее в фоновом режиме.
- CACC (Cached Recent): указывает, что процесс является последним активным клиентом кэша и обычно завершается, когда ему не хватает памяти.
- CRE (кэшированный пустой): указывает, что процесс является кэшированным пустым процессом, у него нет никаких действий или задач.
- CEM (кэшированный пустой и поддерживаемый): указывает, что процесс является кэшированным пустым процессом, но может быть остановлен при нехватке памяти.
- NONE: Указывает, что процесс не имеет состояния или его состояние не может быть определено.

## параметры, связанные с внедрением хуков

Управление памятью A1 v4 может использовать хуки, чтобы предотвратить уничтожение фоновых процессов lmkd. Ниже приведены примеры параметров, используемых для управления этим поведением:

```json
"initInjection": {
	"enable": true,
	"processName": "/system/bin/lmkd",
	"symbolsFunc": "hc_hook",
	"libraryPath": "/data/adb/modules/Hc_memory/lib/arm64-v8a/libhook_lmkd.so",
	"lmkd": {
		"memThreshold": {
			"enable": true,
			"value": 90
		},
		"hookFunc": {
			"kill": true,
			"pidfd_send_signal": true,
			"__android_log_print": false,
			"meminfo": {
				"updateTime": 60
			}
		},
		"model": {
			"inlineHook": "dobby"
		}
	}
}
```

|имя поля |тип |описание |
| ------------- | ------ | ---------- |
|initInjection |object |инъекция инициализации |
|enable |bool |bool ли ловушку lmkd |
|processName |string |имя процесса |
|symbolsFunc |string |Имя функции, которая будет выполняться после хука |
|libraryPath |string |Путь к библиотеке хуков |

Вы можете изменить путь, чтобы внедрить свою библиотеку ловушек в указанный процесс.Я рекомендую использовать абсолютный путь для имени процесса.
- `initInjection` означает инъекцию инициализации.
- `enable` указывает, включать ли хук lmkd. Если установлено значение true, управление памятью A1 будет перехватывать lmkd; если установлено значение false, управление памятью A1 не будет перехватывать lmkd.

### порог памяти

|имя поля |тип |описание |
| ------------ | ------ | ----------------------- |
|memThreshold |object |порог памяти |
|enable |bool |Включить ли порог памяти |
|value |int|Когда использование памяти достигает 90%, больше не препятствовать тому, чтобы lmkd убивал процесс |

Порог памяти — очень важная функция, она позволяет больше не препятствовать тому, чтобы lmkd убивал процесс после того, как использование памяти достигает определенного уровня. Преимущество этого заключается в том, что это может предотвратить зависание системы из-за большого использования памяти, но также приведет к остановке фонового процесса. Таким образом, вы можете контролировать использование памяти до определенного уровня, установив пороговое значение памяти, и больше не запрещать lmkd убивать процесс.
- `memThreshold` представляет функцию порога памяти.
- `enable` указывает, следует ли включить функцию порога памяти. Если установлено значение true, управление памятью A1 активирует функцию порога памяти; если установлено значение false, управление памятью A1 не активирует функцию порога памяти.
- `value` указывает, что когда использование памяти достигает 90%, больше не препятствовать тому, чтобы lmkd убивал процесс.

### Выберите функцию для перехвата

|имя поля |тип |описание |
| ------------------ | ------ | ---------------------------------- |
|hookFunc |object |функция ловушки |
| kill | bool | Перехватывать ли функцию `kill` |
|pidfd_send_signal |bool |будет ли `hook pidfd_send_signal` функция |
| __android_log_print | bool | будет ли `hook __android_log_print` функция |
|meminfo |object |информация о памяти |
|updateTime |int |время обновления в секундах |

- `hookFunc` представляет функцию ловушки.
- для `kill` установлено значение true, чтобы перехватывать функцию kill, управление памятью A1 будет перехватывать функцию kill; установите для него значение false, чтобы не перехватывать функцию kill.
- `pidfd_send_signal` имеет значение true, чтобы перехватывать функцию `pidfd_send_signal`, управление памятью A1 будет цеплять функцию `pidfd_send_signal`, чтобы предотвратить завершение процесса; установите для него значение false, чтобы не цеплять функцию `pidfd_send_signal`.
- Установите для `__android_log_print` значение true, чтобы перехватывать функцию `__android_log_print`, управление памятью A1 будет перехватывать функцию `__android_log_print`; установите для него значение false, чтобы не перехватывать функцию `__android_log_print`. Не рекомендуется включать эту функцию, поскольку это приведет к сбою вывода журнала и может вызвать исключение lmkd.

### Время обновления информации о памяти

Эффективно избегайте потребления производительности, вызванного повторным обновлением информации в памяти meminfo, вы можете контролировать интервал обновления, устанавливая время обновления.
- `meminfo` информация о памяти.
- `updateTime` Время обновления занимаемой памяти в процентах, рекомендуемое значение от 30 до 90. Чем больше значение, тем больше интервал обновления и меньше потребление производительности; чем меньше значение, тем короче интервал обновления и больше потребление производительности.

|имя поля |тип |описание |
| ---------- | ------ | -------------- |
|model |object |модель |
|inlineHook |string |режим inlineHook |

- `model` указывает на образец.
- `inlineHook` по умолчанию использует [dobby](https://github.com/jmpews/Dobby) для изменения адреса функции. Если хук нельзя использовать нормально, вы можете попробовать изменить его на [And64InlineHook](https: //github.com/Rprop/And64InlineHook).

## Разрешить приложению спать, чтобы уменьшить использование ЦП и памяти

Управление памятью A1 v4 позволяет приложениям переходить в спящий режим, чтобы уменьшить использование ЦП и памяти. Ниже приведены примеры параметров, используемых для управления этим поведением:

|имя поля |тип |описание |
| -------- | ------ | ----------------------------------------------------- |
|appSleep |object |приложение сна |
|enable |bool |Включать ли гибернацию приложений для снижения использования ЦП и памяти |
|idle |string |Для пользователей после бездействия все означает все/текущий означает текущего пользователя, текущий не действует на мультиоткрытие |
|bg |string |статус фонового приложения, ignore означает игнорирование запроса на пробуждение и запрос приложения на извлечение |
|top |string |Статус приложения переднего плана, разрешить означает разрешить запросы пробуждения и запросы приложений подтягивания |

- для `enable` установлено значение true, чтобы включить спящий режим приложения для сокращения операций использования ЦП и памяти; установите значение false, чтобы не выполнять.
- настройка `idle` для пользователя после бездействия. Необязательные значения: все (все пользователи) и текущий (текущий пользователь), где текущий не влияет на мультиоткрытие.
- `bg` настройки состояния фонового приложения. Необязательные значения: игнорировать (игнорировать запрос пробуждения и запрос приложения подтягивания), разрешить (разрешить запрос пробуждения и запрос приложения подтягивания), запретить (запретить запрос пробуждения и запрос приложения подтягивания). .
- `top` установка состояния приложения переднего плана. Необязательные значения такие же, как и у параметра bg.

## милый режим

Проще говоря, это означает убить подпроцесс приложения и попытаться предотвратить подтягивание подпроцесса основным процессом, чтобы приложение могло уменьшить использование ЦП и памяти.
Чтобы удовлетворить потребности большего количества людей, управление памятью A1 v4 по умолчанию включает некоторые подпроцессы приложений, но это может по-прежнему не охватывать все ситуации. Если вам нужно УБИТЬ другие дочерние процессы, вы можете добавить их, отредактировав файл list.conf. Ниже приведен пример формата файла roster-list.conf:
```
KILL Имя пакета:имя дочернего процесса
```

|имя поля |тип |описание |
| ------ | ------ | ---------------- |
|clever |object |умный режим |
|enable |bool |Включать ли интеллектуальный режим |

## безумно бойня

Вызовите API ядра, чтобы убить некоторые процессы.Принцип пока не ясен, но он может эффективно убить некоторые процессы. Я думаю, об этом можно судить по значению oom. Ниже приведены примеры параметров, используемых для управления этим поведением:

|имя поля |тип |описание |
| --------- | ------ | ---------------- |
|crazyKill |object |безумное убийство |
|enable |bool |Разрешить ли безумное убийство |

## Записать содержимое в файл

Содержимое может быть записано в файл. Ниже приведены примеры параметров, используемых для управления этим поведением:

```json
"file": {
    "write": [
        {
            "path": "/proc/sys/fs/inotify/max_queued_events",
            "content": "102400"
        },
        {
            "path": "/proc/sys/fs/inotify/max_user_watches",
            "content": "102400"
        },
        ...
    ]
}
```

В приведенном выше примере мы записали содержимое в два файла, тем самым активировав функцию inotify.

|имя поля |тип |описание |
| ------ | ----- | -------------- |
|write |array |запись содержимого в файл |
|path |string |путь к файлу |
|content |string |письменный контент |

### После изменения файла конфигурации необходимо перезагрузить телефон или завершить процесс HC_memory, чтобы изменения вступили в силу.

## Спасибо

Благодаря исходному коду следующих пользователей или проектов за их помощь в этом проекте:
- [@yc9559](https://github.com/yc9559)
- [@HChenX](https://github.com/HChenX)

Спасибо следующим пользователям за отзывы о тестировании и обнаружение ошибок:
- @火機(coolapk)

## Пожертвовать на поддержку
Как вы думаете, этот модуль очень полезен, вы можете пожертвовать, чтобы поддержать меня
- [爱发电](https://afdian.net/a/HCha1)
- [patreon](https://patreon.com/A1memory)
- USDT(TRC20)
  > Address: TSqTqn2NcyUAbEwsdGgsrYoU5pokno5PnQ
